Theme,Question,Answer
"Консольные, Desktop и клиент-серверные и web-приложения(как частный случай клиент-сервера)",Консольные приложения,"Прикладные приложения, непредусматривающие свой собственный графический интерфейс"
"Консольные, Desktop и клиент-серверные и web-приложения(как частный случай клиент-сервера)",Примеры консольных приложений,"FTP клиенты, некоторые файловые менеджеры могут работать в консольном режиме,"
"Консольные, Desktop и клиент-серверные и web-приложения(как частный случай клиент-сервера)",Desktop приложения,Прикладные приложения работающие в среде операционной системы. Приложение инсталлируется на рабочую станцию пользователя и запускается локально или удаленно.
"Консольные, Desktop и клиент-серверные и web-приложения(как частный случай клиент-сервера)",Клиент-серверные приложения,"Приложения реализующие клиент-серверную архитектуру. Обработка данных осуществляется на стороне сервера.
Плюсы: низкие требования к машинам на которых установлен клиент, данные хранятся на сервере."
"Консольные, Desktop и клиент-серверные и web-приложения(как частный случай клиент-сервера)",web-приложения,"Клиент-серверное приложение, в котором клиентом выступает браузер, а сервером web-сервер. Логика веб-приложения распределена между сервером и клиентом, хранение данных осуществляется, преимущественно, на сервере, обмен информацией происходит по сети. Может выступать в качестве клиента других служб, например, базы данных или другого веб-приложения, расположенного на другом сервере"
"Консольные, Desktop и клиент-серверные и web-приложения(как частный случай клиент-сервера)",клиентская часть,"Реализует пользовательский интерфейс, формирует запросы к серверу и обрабатывает ответы от него"
"Консольные, Desktop и клиент-серверные и web-приложения(как частный случай клиент-сервера)",серверная часть,"Получает запрос от клиента, выполняет вычисления, после этого формирует веб-страницу и отправляет ее клиенту"
Язык XML,XML,"eXtensible Markup Language (расширяемый язык разметки). Спецификация XML описывает XML-документы и частично описывает поведение XML-процессоров (программ, читающих XML-документы и обеспечивающих доступ к их содержимому). XML разрабатывался как язык с простым формальным синтаксисом, удобный для создания и обработки документов программами и одновременно удобный для чтения и создания документов человеком, с подчёркиванием нацеленности на использование в Интернете. Язык называется расширяемым, поскольку он не фиксирует разметку, используемую в документах: разработчик волен создать разметку в соответствии с потребностями к конкретной области, будучи ограниченным лишь синтаксическими правилами языка."
Язык XML,Использование XML,"XML отделяет данные от HTML -можно хранить данные в XML файле и подгружать по необходимости, а не каждый раз править HTML код
XML упрощает распределение данных позволяя использовать их самыми разными приложениями
XML упрощает передачу данных, например между несовместимыми между собой приложениями
XML упрощает модификацию платформы, позволяя производить модернизацию без риска потери данных"
Язык XML,Дерево XML,"XML документы формируют древовидную структуру, которая начинается с ""корневого"" элемента и разветвляется на ""дочерние"" элементы."
Язык XML,Корневой элемент,"XML документ должен содержать корневой элемент. Этот элемент является ""родительским"" для всех других элементов."
Язык XML,Пример,"<корневой>
   <потомок>
      <подпотомок>.....</подпотомок>
   </потомок>
</корневой>"
Язык XML,Правила синтаксиса XML,"Все XML элементы должны иметь закрывающий тег
Теги XML регистрозависимы
XML элементы должны соблюдать корректную вложенность (если элемент открывается внутри другого элемента, то и закрываться он должен внутри него
У XML документа должен быть корневой элемент
Значения XML атрибутов должны заключаться в кавычки
Некоторые символы должны заменяться на их сущности (&lt; <) (&gt; >) (&amp; &) (&apos; ') (&quot; "")
Комментарии должны иметь следующий синтаксис <!-- Это комментарий -->
В XML пробелы сохраняются
В XML новая строка сохраняется как LF
Если все вышееперечисленные правила выполнятся - документ считается синтаксически верным XML документом"
Язык XML,XML элемент,"Составляющая часть xml документа. Включается в себя все от начального тега элемента до конечного тега элемента. Элемент может содержать: другие элементы, текст, атрибуты или набор из всего выше названного"
Язык XML,Пустой XML элемент,"При написании элементов без контента можно использовать альтернативный синтаксис. Вместо того, чтобы писать пустой элемент в виде: <book></book>
Можно написать: <book /> Такой синтаксис элемента называется самозакрывающийся."
Язык XML,Правила написания имен XML,"XML элементы должны следовать следующим правилам написания имен:
Имена могут содержать буквы, числа и другие символы
Имена не могут начинаться с цифры или символа пунктуации
Имена не могут начинаться с сочетания ""xml"" (или XML, или Xml и т.п.)
Имена не могут содержать пробельные символы
В качестве имен можно использовать любые слова. Нет зарезервированных слов."
Язык XML,Расширяемость XML элементов,"XML элементы могут быть расширены, чтобы нести больше информации, при этом это не повлияет на работу уже существующих приложений"
Язык XML,XML атрибуты,"Атрибуты предоставляют дополнительную информацию об элементе. При использовании атрибутов возникают некоторые проблемы:
атрибуты не могут содержать множественные значения (элементы могут)
атрибуты не могут содержать древовидные структуры (элементы могут)
атрибуты сложно расширять (для будущих изменений)
Атрибуты нелегко читать и обслуживать. Используйте элементы для данных, а атрибуты для информации, не относящейся к данным (например, метаданным)"
Язык XML,XML пространства имен,"Стандарт, описывающий именованную группу имён элементов и атрибутов, служащую для обеспечения их уникальности в XML-документе. Декларация пространства имен имеет следующий синтаксис - xmlns:префикс=""URI"". Пространства имен могут декларироваться либо непосредственно в самом элементе, либо в корневом элементе XML документа. URI пространства имен не используется парсером для получения какой-либо информации. Цель всего этого состоит в том, чтобы дать пространству имен уникальное имя. Определение пространства имен по умолчанию позволяет избежать использования префиксов во всех дочерних элементах. Такое определение имеет следующий синтаксис:
xmlns=""URI пространства имен"""
Язык XML,Кодировка в XML документе,"XML документы могут содержать символы в различных международных кодировках. Чтобы не возникало ошибок, необходимо указывать, какая кодировка используется в XML документе, либо сохранять файл в универсальной кодировке UTF-8."
Язык XML,Пролог XML,"Первая строка в XML документе называется прологом. Пролог является необязательным и, как правило, содержит номер версии XML. Кроме этого, он может содержать информацию о кодировке XML документа. Следующий пролог определяет кодировку UTF-8:
<?xml version=""1.0"" encoding=""UTF-8""?>"
Язык XML,Отображение XML с CSS,"При помощи CSS можно добавить в XML документ информацию о правилах вывода.
<?xml-stylesheet type=""text/css"" href=""http://msiter.ru/cd_catalog.css""?>
Форматирование вывода XML при помощи CSS используется довольно редко. Вместо этого W3C рекомендует использовать XSLT."
Язык XML,Валидные XML документы,"Валидный XML документ не то же самое, что и синтаксически верный XML документ.
Первое правило для валидного XML документа то, что он должен быть синтаксически верным.
Второе правило — валидный XML документ должен соответствовать определенному типу документов.
Правила, определяющие допустимые элементы и атрибуты для XML документа, часто называются определениями документа или схемами документа."
Язык XML,DTD,"Цель DTD (Определение типов документа - Document Type Definition) состоит в определении допустимых строительных блоков XML документа.
DTD определяет структуру документа со списком допустимых элементов и атрибутов. Пример декларации:
<!DOCTYPE note SYSTEM ""Note.dtd"">"
Язык XML,Пример DTD,"<!DOCTYPE note [                                                                 определяет что корневым элементом является note
<!ELEMENT note (to,from,heading,body)>                       определяет, что элемент note содержит четыре элемента: to, from, heading, body
<!ELEMENT to (#PCDATA)>                                                  определяет, что элемент to должен быть типа ""#PCDATA""
<!ELEMENT from (#PCDATA)>
<!ELEMENT heading (#PCDATA)>
<!ELEMENT body (#PCDATA)>
]>"
Язык XML,XML схемы,"Также, как и XML DTD, XML схемы описывают структуру XML документа. XML схема является основанной на XML альтернативой DTD"
Язык XML,Пример XML схемы,"<xs:element name=""note"">                                                         определяет элемент ""note""
   <xs:complexType>                                                                     у элемента ""note"" комплексный тип
      <xs:sequence>                                                                         комплексный тип — это последовательность элементов
         <xs:element name=""to"" type=""xs:string""/>                      у элемента ""to"" строковый тип (текст)
         <xs:element name=""from"" type=""xs:string""/>
         <xs:element name=""heading"" type=""xs:string""/>
         <xs:element name=""body"" type=""xs:string""/>
      </xs:sequence>
   </xs:complexType>
</xs:element>"
Язык XML,Плюсы по сравнению с DTD,"XML схема пишется на XML
XML схема легко расширяется
XML схема поддерживает типы данных
XML схема поддерживает пространства имен"
Язык XML,Причины использования DTD и XML схем,"С DTD ваш XML файл может нести собственный формат
С DTD различные, не связанные друг с другом группы людей могут приходить к соглашению о стандартах пересекающихся данных
С DTD вы можете быть уверены, что получаемые из внешних источников данные будут корректными"
Язык XML,XML парсер,"XML-процессор (парсер) — программа, анализирующая разметку и передающая информацию о структуре документа другой программе — приложению.
Процессоры делятся на проверяющие действительность документа и не проверяющие"
Язык XML,XPath,Язык для поиска информации внутри XML документа.
Язык XML,XSLT,"eXtensible Stylesheet Language Transformations (язык преобразования XML документов), является рекомендованным языком таблиц стилей для XML
XSLT более сложный язык таблиц стилей, чем CSS. Используя XSLT вы можете добавлять/удалять элементы и атрибуты в конечном файле отображения. Также, вы можете реорганизовывать и сортировать элементы, осуществлять проверки и принимать решения о том, какие элементы скрывать, а какие отображать."
Язык XML,XLink,"XLink используется для создания гиперссылок внутри XML документов
Любой элемент XML документа может вести себя как ссылка
XLink поддерживает простые ссылки (как HTML) и расширенные ссылки (для связывания нескольких ресурсов)
При помощи XLink ссылки могут определяться за пределами связанных файлов
XLink является стандартом W3C"
Язык XML,XPointer,"XPointer позволяет создавать ссылки на различные части XML документа
XPointer использует выражения XPath для навигации по XML документу
XPointer является стандартом W3C"
Язык XML,CDATA,"Текстовые данные XML. Весь текст в XML документе анализируется парсером. 
PCDATA - анализируемые символьные данные
CDATA- неанализируемые символьные данные"
Язык XML,Чтение XML,Для чтения XML есть три варианта API
Язык XML,Событийный API,"XML-процессор читает XML; при определённом событии (появлении открывающего или закрывающего тега, текстовой строки, атрибута) вызывается callback-функция."
Язык XML,Потоковый API,"Устроен на манер потоков ввода-вывода. Как и в событийном API, для простоты программирования процессор может собирать в памяти все атрибуты одного тега на манер DOM"
Язык XML,Объектный API,"(Document Object Model, DOM, «объектная модель документа») - считывает XML и воссоздаёт его в памяти в виде объектной структуры."
Язык XML,Запись XML,Для записи XML есть два варианта API
Язык XML,API прямой записи,"Записывает XML тег за тегом, атрибут за атрибутом"
Язык XML,Объектный API,"Document Object Model, создаёт объектную структуру для XML"
Web Services,Веб-служба,"Идентифицируемая веб-адресом программная система со стандартизированными интерфейсами. Веб-службы могут взаимодействовать друг с другом и со сторонними приложениями посредством сообщений, основанных на определённых протоколах (SOAP, XML-RPC, REST и т. д.)
Веб службы располагаются на серверах приложений"
Web Services,SOAP,"Simple Object Access Protocol (простой протокол доступа к объектам) - протокол обмена структурированными сообщениями в распределённой вычислительной среде. Первоначально SOAP предназначался в основном для реализации удалённого вызова процедур (RPC). Сейчас протокол используется для обмена произвольными сообщениями в формате XML, а не только для вызова процедур. SOAP может использоваться с любым протоколом прикладного уровня: SMTP, FTP, HTTP, HTTPS и др. Однако его взаимодействие с каждым из этих протоколов имеет свои особенности, которые должны быть определены отдельно. Чаще всего SOAP используется поверх HTTP."
Web Services,XML-RPC," Extensible Markup Language Remote Procedure Call (XML-вызов удалённых процедур) - стандарт/протокол вызова удалённых процедур, использующий XML для кодирования своих сообщений и HTTP в качестве транспортного механизма. Является прародителем SOAP, отличается исключительной простотой в применении. XML-RPC, как и любой другой интерфейс Remote Procedure Call (RPC), определяет набор стандартных типов данных и команд, которые программист может использовать для доступа к функциональности другой программы, находящейся на другом компьютере в сети."
Web Services,REST,"Representational State Transfer (передача состояния представления) -  архитектурный стиль взаимодействия компонентов распределённого приложения в сети. REST представляет собой согласованный набор ограничений, учитываемых при проектировании распределённой гипермедиа-системы. REST является альтернативой RPC
В сети Интернет, вызов удалённой процедуры может представлять собой обычный HTTP-запрос (обычно «GET» или «POST»; такой запрос называют «REST-запрос»), а необходимые данные передаются в качестве параметров запроса.
Для веб-служб, построенных с учётом REST (то есть не нарушающих накладываемых им ограничений), применяют термин «RESTful».
В отличие от веб-сервисов (веб-служб) на основе SOAP, не существует «официального» стандарта для RESTful веб-API. Дело в том, что REST является архитектурным стилем, в то время как SOAP является протоколом. Несмотря на то, что REST не является стандартом сам по себе, большинство RESTful-реализаций используют стандарты, такие как HTTP, URL, JSON и XML."
Web Services,Архитектура,"Можно выделить три инстанции, взаимодействующие в рамках веб-службы. заказчик (service requester), исполнитель (service provider) и каталог (service broker).
Когда служба разработана, исполнитель регистрирует её в каталоге, где её могут найти потенциальные заказчики. Заказчик, найдя в каталоге подходящую службу, импортирует оттуда её WSDL-спецификацию и разрабатывает в соответствии с ней своё программное обеспечение. WSDL описывает формат запросов и ответов, которыми обмениваются заказчик и исполнитель в процессе работы. Для обеспечения взаимодействия используются следующие стандарты:
XML: Расширяемый язык разметки, предназначенный для хранения и передачи структурированных данных;
SOAP: Протокол обмена сообщениями на базе XML;
WSDL: Язык описания внешних интерфейсов веб-службы на базе XML;
UDDI: Универсальный интерфейс распознавания, описания и интеграции (Universal Discovery, Description and Integration). Каталог веб-служб и сведений о компаниях, предоставляющих веб-службы во всеобщее пользование или конкретным компаниям. Пока UDDI существуют, однако, только в небольших фирменных сетях и ещё не нашли широкого распространения в открытом интернете."
Web Services,WSDL,"Web Services Description Language — язык описания веб-сервисов и доступа к ним, основанный на языке XML. Каждый документ WSDL 1.1 можно разбить на следующие логические части:
определение типов данных (types) — определение вида отправляемых и получаемых сервисом XML-сообщений
элементы данных (message) — сообщения, используемые web-сервисом
абстрактные операции (portType) — список операций, которые могут быть выполнены с сообщениями
связывание сервисов (binding) — способ, которым сообщение будет доставлено"
Web Services,UDDI,"Universal Description Discovery & Integration - инструмент для расположения описаний веб-сервисов (WSDL) для последующего их поиска другими организациями и интеграции в свои системы. UDDI это кроссплатформенное программное обеспечение, основанное на XML. UDDI является открытым проектом, спонсируемым OASIS, который позволяет организациям публиковать описания веб-сервисов (WSDL) для последующего их поиска другими организациями и интеграции в свои системы, а также определять, как сервисы или приложения взаимодействуют через Internet."
Web Services,Методы разработки,"Существуют средства автоматизации разработки веб-служб, разделяющиеся на две основные группы"
Web Services,Снизу-вверх,"Сначала пишутся имплементирующие классы, а из их исходного текста генерируются WSDL-файлы, документирующие службу. Недостатком этого метода является подверженность Java-классов частым изменениям."
Web Services,Сверху-вниз,"Сначала подготавливается WSDL, а из него генерируется скелет Java-класса, имплементирующего службу. Этот путь считается более трудным, зато приводит к более чистым и лучше защищенным от изменений решениям. Пока формат сообщений, которыми обмениваются заказчик и исполнитель, не меняется, изменения в каждом из них не нарушают взаимодействия. Эта техника называется иногда «contract first», так как исходной точкой является WSDL («договор» между заказчиком и исполнителем)."
Web Services,Преимущества,"Веб-службы обеспечивают взаимодействие программных систем независимо от платформы. Например, Windows-C#-клиент может коммуницировать с Java-сервером, работающим под Linux.
Веб-службы основаны на базе открытых стандартов и протоколов. Благодаря использованию XML достигается простота разработки и отладки веб-служб.
Использование интернет-протокола обеспечивает HTTP-взаимодействие программных систем через межсетевой экран. Это значительное преимущество, по сравнению с такими технологиями, как CORBA, DCOM или Java RMI. С другой стороны, веб-службы не привязаны намертво к HTTP — могут использоваться и другие протоколы."
Web Services,Недостатки,"Меньшая производительность и больший размер сетевого трафика по сравнению с технологиями RMI, CORBA, DCOM за счёт использования текстовых XML-сообщений. Однако на некоторых веб-серверах возможна настройка сжатия сетевого трафика.
Аспекты безопасности. Ответственные веб-службы должны использовать кодирование, возможно — требовать аутентификации пользователя. Достаточно ли здесь применения HTTPS, или предпочтительны такие решения, как XML Signature, XML Encryption или SAML — должно быть решено разработчиком."
ООП,ООП,"Методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования"
ООП,Объект ,"Некоторая сущность в компьютерном пространстве, обладающая определённым состоянием и поведением, имеющая заданные значения свойств (атрибутов) и операций над ними (методов). Как правило, при рассмотрении объектов выделяется то, что объекты принадлежат одному или нескольким классам, которые определяют поведение (являются моделью) объекта. Термины «экземпляр класса» и «объект» взаимозаменяемы"
ООП,Класс,"Универсальный, комплексный тип данных, состоящий из тематически единого набора «полей» (переменных более элементарных типов) и «методов» (функций для работы с этими полями), то есть он является моделью информационной сущности с внутренним и внешним интерфейсами для оперирования своим содержимым (значениями полей)."
ООП,Абстракция данных,"Абстрагирование — это способ выделить набор значимых характеристик объекта, исключая из рассмотрения не значимые  Соответственно, абстракция — это набор всех таких характеристик. Этот концептуальный подход позволяет объединить тип данных с множеством операций, которые допустимо выполнять над этим типом данных. Абстракция данных позволяет рассматривать необходимые объекты данных и операции, которые должны выполняться над такими объектами, без необходимости вникать в несущественные детали."
ООП,Уровень абстракции,"Один из способов сокрытия деталей реализации определенного набора функциональных возможностей. Применяется для управления сложностью проектируемой системы при декомпозиции, когда система представляется в виде иерархии уровней абстракции."
ООП,Инкапсуляция,"Свойство системы, позволяющее объединить данные и методы, работающие с ними в классе, и скрыть детали реализации от пользователя.
В ООП инкапсуляция тесно связана с принципом абстракции данных. В общем случае в разных языках программирования термин «инкапсуляция» относится к одной или обеим одновременно следующим нотациям:
механизм языка, позволяющий ограничить доступ одних компонентов программы к другим
языковая конструкция, позволяющая связать данные с методами, предназначенными для обработки этих данных
Пренебрегая формализмом и способствуя интуитивному восприятию, инкапсуляцию можно определить с помощью латинского in capsula — размещение в оболочке, изоляция, закрытие чего-либо инородного с целью исключения влияния на окружающее, обеспечение доступности главного, выделение основного содержания путём помещения всего мешающего, второстепенного в некую условную капсулу (чёрный ящик)."
ООП,Наследование,"Свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым, родительским или суперклассом. Новый класс — потомком, наследником или производным классом"
ООП,Полиморфизм,В языках программирования и теории типов полиморфизмом называется способность функции обрабатывать данные разных типов. Существует несколько разновидностей полиморфизма.
ООП,Параметрический,"Параметрический полиморфизм подразумевает исполнение одного и того же кода для всех допустимых типов аргументов. Параметрически полиморфная функция использует аргументы на основе поведения, а не значения, апеллируя лишь к необходимым ей свойствам аргументов, что делает её применимой в любом контексте, где тип объекта удовлетворяет заданным требованиям поведения."
ООП,Подтипов,"Свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.
Более простым языком - возможность использования экземпляра класса-наследника там, где требуется экземпляр базового класса. (Это определение можно легко расширить и на интерфейсы, если учесть, что интерфейс — это чисто абстрактный класс.)
Пример - есть класс Animal - базовый тип обладающий одним методом talk. Далее у нас есть два дочерних класса - Cat и Dog, каждый из которых переопределяет метод Talk своим собственным поведением, соответствующим этому классу. Если, например в методе другого класса, мы будем передавать ему объект типа  Animal и вызывать метод Talk - мы будем получать разное поведение данного метода. При этом метод другого класса не знает ничего о фактическом типе объекта, а пользуется только объявленным интерфейсом."
ООП,Ad hoc,"Поддерживается во многих языках посредством перегрузки (возможность использования одноимённых подпрограмм) функций и методов, а в слабо типизированных — также посредством приведения типов. Не является истинным полиморфизмом. Перегрузка функций даёт не «значение, имеющее множество типов», а «символ, имеющий множество типов», но значения, идентифицируемые этим символом, имеют разные (потенциально не совместимые) типы. Аналогично, приведение типов не является истинным полиморфизмом: кажется, будто оператор принимает значения множества типов, но значения должны быть преобразованы к некоторому представлению до того, как он сможет их использовать, так что на самом деле оператор работает лишь над одним типом (то есть имеет один тип). Более того, тип возвращаемого значения здесь не зависит от типа входного параметра, как в случае параметрического полиморфизма."
ООП,UML,"Unified Modeling Language (унифицированный язык моделирования) -  язык графического описания для объектного моделирования в области разработки программного обеспечения, моделирования бизнес-процессов, системного проектирования и отображения организационных структур."
ООП,Диаграмма классов UML,"Диаграмма, демонстрирующая классы системы, их атрибуты, методы и взаимосвязи между ними."
ООП,Ассоциация,Ассоциация показывает отношения между объектами-экземплярами класса. Бывает бинарной (у каждого сотрудника есть id пропуск) и N-арная (за каждым работником закреплено сколько-то помещений)
ООП,Агрегация и композиция,"Агрегация -  разновидность ассоциации. Встречается, когда один класс является коллекцией или контейнером других. Причём по умолчанию, агрегацией называют агрегацию по ссылке, то есть когда время существования содержащихся классов не зависит от времени существования содержащего их класса. Если контейнер будет уничтожен, то его содержимое — нет. (отдел агрегирует работающих в нем сотрудников)
Композиция -  более строгий вариант агрегации. Композиция имеет жёсткую зависимость времени существования экземпляров класса контейнера и экземпляров содержащихся классов. Если контейнер будет уничтожен, то всё его содержимое будет также уничтожено. (у каждого сотрудника есть информация о ранее занимаемой им должности)"
ООП,Обобщение/расширение (наследование),"Обобщение показывает, что один из двух связанных классов (подтип) является частной формой другого (надтипа), который называется обобщением первого. На практике это означает, что любой экземпляр подтипа является также экземпляром надтипа. Например: животные — супертип млекопитающих, которые, в свою очередь, — супертип приматов, и так далее."
ООП,Реализация,"Отношение между двумя элементами модели, в котором один элемент (клиент) реализует поведение, заданное другим (поставщиком)."
ООП,Зависимость,"Слабая форма отношения использования, при котором изменение в спецификации одного влечёт за собой изменение другого, причём обратное не обязательно. Возникает, когда объект выступает, например, в форме параметра или локальной переменной."
ООП,Уточнения отношений,"Имеет отношение к уровню детализации. Один пакет уточняет другой, если в нём содержатся те же самые элементы, но в более подробном представлении."
ООП,Мощность отношений (Кратность),Означает число связей между между каждым экземпляром класса (объектом) в начале линии с экземпляром класса в её конце.
ООП,Абстрактный класс,"Это «заготовка» класса: может быть реализовано большинство методов (включая внутренние), кроме нескольких. Эти несколько нереализованных методов вполне могут быть внутренними методами класса, они лишь уточняют детали имплементации. Абстрактный класс — средство для повторного использования кода, средство, чтобы указать, какой метод обязан быть перекрыт для завершения написания класса.
Другими словами, абстрактный класс  может содержать невиртуальные методы, виртуальные методы метод может быть переопределен в классах наследниках) и абстрактные методы (метод с отсутствующей реализацией, которая должна быть определена в классе наследнике)."
ООП,Интерфейс в ООП,Описывает некоторое семейство типов и содержит лишь декларации операций
ООП,Плюсы интерфейсов,"Выделение интерфейсов в отдельную категорию полезно не только с точки зрения упрощения реализации языков программирования, но и для выделения разных подходов к моделированию. Так, например, наследование классов моделирует отношение «Является» («Кнопка меню» ЯВЛЯЕТСЯ «Кнопкой»), а базовые классы обычно содержат определенный функционал, тесно связанный с функционалом производного класса. Базовые классы не просто моделируют группу типов, но и позволяют использовать повторно существующий функционал.
Интерфейсы же, по своей природе обладают меньшей связностью (low coupling), поскольку не обладают конкретным поведением, которое может осложнить жизнь класса-наследника. Интерфейсы также могут моделировать отношение «Является» («Кнопка меню» ЯВЛЯЕТСЯ «IКнопкой»), но могут определять и менее жесткое отношение «Может выполнять роль»"
Программирование. Типы данных,Тип данных,"Класс данных, характеризуемый членами класса и операциями, которые могут быть к ним применены"
Программирование. Типы данных,Система типов,"Совокупность правил в языках программирования, назначающих свойства, именуемые типами, различным конструкциям, составляющим программу — таким как переменные, выражения, функции или модули. Технически, система типов назначает тип каждому вычисленному значению и затем, отслеживая последовательность этих вычислений, предпринимает попытку проверить или доказать отсутствие ошибок согласования типов. Конкретная система типов может определять, что именно приводит к ошибке, но обычно целью является предотвращение того, чтобы операции, предполагающие определённые свойства своих параметров, получали параметры, для которых эти операции не имеют смысла — предотвращение логических ошибок. Дополнительно это также предотвращает ошибки адресации памяти."
Программирование. Типы данных,Проверка согласования типов,"Может осуществляться как на стадии компиляции (статическая типизация), так и на стадии исполнения (динамическая типизация). Если спецификация языка требует, чтобы правила типизации исполнялись строго (то есть в допуская в той или иной мере лишь те автоматические преобразования типов, которые не теряют информацию), такой язык называется сильно типизированным, в противном случае — слабо типизированным."
Программирование. Типы данных,Статическая и динамическая типизации,"Переменная связывается с типов на стадии объявления, и тип не может быть изменен в дальнейшем.
Переменная связывается с типом в момент присваивания значения"
Программирование. Типы данных,Сильная и слабая типизация,"Сильная и слабая типизации характеризуются наличием или отсутствием безопасности согласования типов и безопасности доступа к памяти, а также характерным временем осуществления такого контроля (в статике или в динамике)."
Программирование. Типы данных,Типобезопасность (безопасность согласования типов),"Система типов называется безопасной, если в программах, прошедших проверку согласования типов, исключена возможность возникновения ошибок согласования типов во время выполнения"
Программирование. Типы данных,Утиная типизация,"Вид динамической типизации, применяемой в некоторых языках программирования, которая позволяет полиморфно работать с объектами, которые не связаны в иерархии наследования, но имеют необходимый набор методов. То есть считается, что объект реализует интерфейс, если он содержит все методы этого интерфейса, независимо от связей в иерархии наследования и принадлежности к какому-либо конкретному классу."
Программирование. Типы данных,Распространенные типы данных,"Логический, целочисленный, числа с плавающей точкой, строки, указатели, идентификационные типы, абстрактные типы данных (список, стек, очередь, словарь)"
Программирование. Операторы и операнды,"Оператор(инструкция, statement)","Наименьшая автономная часть языка программирования; команда или набор команд. Программа обычно представляет собой последовательность инструкций.
Из-за путаницы с терминологией словом «оператор» в программировании нередко обозначают операцию (англ. operator)"
Программирование. Операторы и операнды,Операция (operator),"Конструкция в языках программирования, аналогичная по записи математическим операциям, то есть специальный способ записи некоторых действий. Наиболее часто применяются арифметические, логические и строковые операции."
Программирование. Операторы и операнды,Операция и функция,"Фактически, операция — это та же функция, но записываемая особым образом. По этой причине логично иметь возможность определять операции для произвольных типов таким же образом, как и методы — чтобы можно было работать с ними точно так же, как и с элементарными типами. Эта возможность называется «перегрузка операций» и присутствует в большинстве языков 4—5 поколений. В таких языках транслятор фактически подставляет вместо выполнения операции вызов соответствующей ей функции."
Программирование. Операторы и операнды,Типы операций,"Операции делятся по количеству принимаемых аргументов(операндов) на:
унарные — один аргумент (отрицание, унарный минус);
бинарные — два аргумента (сложение, вычитание, умножение и т. д.);
тернарные — три аргумента («условие ? выражение1 : выражение2»)."
Программирование. Операторы и операнды,Операнд,"Аргумент операции; данные, которые обрабатываются командой; грамматическая конструкция, обозначающая выражение, задающее значение аргумента операции. Иногда операндом называют место, позицию в тексте, где должен стоять аргумент операции. Отсюда понятие местности операции, то есть числа аргументов операции."
Программирование. Процедуры и функции,Подпрограмма,"Поименованная или иным образом идентифицированная часть компьютерной программы, содержащая описание определённого набора действий. Подпрограмма может быть многократно вызвана из разных частей программы. В языках программирования для оформления и использования подпрограмм существуют специальные синтаксические средства."
Программирование. Процедуры и функции,Причины появления подпрограмм,"Подпрограммы изначально появились как средство оптимизации программ по объёму занимаемой памяти — они позволили не повторять в программе идентичные блоки кода, а описывать их однократно и вызывать по мере необходимости. К настоящему времени данная функция подпрограмм стала вспомогательной, главное их назначение — структуризация программы с целью удобства её понимания и сопровождения."
Программирование. Процедуры и функции,Параметры подпрограмм,"Принятые подпрограммой аргументы. Термин «аргумент» подразумевает, что конкретно и какой конкретной подпрограмме было передано, а параметр — в каком качестве подпрограмма применила это принятое. То есть вызывающий код передает аргумент в параметр."
Программирование. Процедуры и функции,Формальный параметр,"Аргумент, указываемый при объявлении или определении функции"
Программирование. Процедуры и функции,Фактический параметр,"Аргумент, передаваемый в функцию при её вызове. При вызове подпрограммы фактические параметры, указанные в команде вызова, становятся значениями соответствующих формальных параметров, чем и обеспечивается передача данных в подпрограмму."
Программирование. Процедуры и функции,Способ передачи параметров в подпрограмму,Существует несколько способов передачи параметров в подпрограмму
Программирование. Процедуры и функции,Передача параметров по значению,"Формальному параметру присваивается значение фактического параметра. В этом случае формальный параметр будет содержать копию значения, имеющегося в фактическом, и никакое воздействие, производимое внутри подпрограммы на формальные параметры, не отражается на параметрах фактических. Так, если в качестве фактического параметра будет использована переменная, и внутри подпрограммы значение соответствующего формального параметра будет изменено, то фактический параметр останется без изменений."
Программирование. Процедуры и функции,Передача параметров по ссылке,"В формальный параметр может быть помещён сам фактический параметр (обычно это реализуется путём помещения в формальный параметр ссылки на фактический). При этом любое изменение формального параметра в подпрограмме отразится на фактическом параметре — оба параметра во время вызова подпрограммы суть одно и то же. Параметры, передаваемые по ссылке, дают возможность не только передавать параметры внутрь подпрограммы, но и возвращать вычисленные значения в точку вызова. Для этого параметру внутри подпрограммы просто присваивается нужное значение, и после возврата из подпрограммы переменная, использованная в качестве фактического параметра, получает это значение."
Программирование. Процедуры и функции,Передача параметров по имени," В формальный параметр может быть помещено произвольное выражение. При этом вычисление этого выражения произойдёт внутри подпрограммы в тот момент, когда потребуется его значение. Если это значение фигурирует несколько раз, то и вычисляться оно будет тоже несколько раз."
Программирование. Процедуры и функции,Передача параметров через стек,"Это фактически разновидность передачи параметра по значению, в данном случае отсутствует понятие формальных и фактических параметров. Все параметры лежат на стеке, причём их типы, количество и порядок не контролируются компилятором."
Программирование. Процедуры и функции,Процедура,"Независимая именованная часть программы, которую после однократного описания можно многократно вызвать по имени из последующих частей программы для выполнения определенных действий."
Программирование. Процедуры и функции,Функция,"Подпрограмма специального вида, которая, кроме получения параметров, выполнения действий и передачи результатов работы через параметры имеет ещё одну особенность— она всегда должна возвращать результат. Вызов функции является, с точки зрения языка программирования, выражением, он может использоваться в других выражениях или в качестве правой части присваивания."
Программирование. Процедуры и функции,Анонимная функция,"Особый вид функций, которые объявляются в месте использования и не получают уникального идентификатора для доступа к ним."
Программирование. Процедуры и функции,Метод,"В объектно-ориентированном программировании функции, объявления которых являются неотъемлемой частью определения класса"
Программирование. Разработка сверху-вниз,Сверху-вниз,"Сначала пишется текст основной программы, в котором, вместо каждого связного логического фрагмента текста, вставляется вызов подпрограммы, которая будет выполнять этот фрагмент. Вместо настоящих, работающих подпрограмм, в программу вставляются фиктивные части — заглушки. Заглушка удовлетворяет требованиям интерфейса заменяемого фрагмента (модуля), но не выполняет его функций или выполняет их частично. Затем заглушки заменяются или дорабатываются до настоящих полнофункциональных фрагментов (модулей) в соответствии с планом программирования. На каждой стадии процесса реализации уже созданная программа должна правильно работать по отношению к более низкому уровню. Полученная программа проверяется и отлаживается.
После того, как программист убедится, что подпрограммы вызываются в правильной последовательности (то есть общая структура программы верна), подпрограммы-заглушки последовательно заменяются на реально работающие, причём разработка каждой подпрограммы ведётся тем же методом, что и основной программы. Разработка заканчивается тогда, когда не останется ни одной заглушки. Такая последовательность гарантирует, что на каждом этапе разработки программист одновременно имеет дело с обозримым и понятным ему множеством фрагментов, и может быть уверен, что общая структура всех более высоких уровней программы верна. При сопровождении и внесении изменений в программу выясняется, в какие именно процедуры нужно внести изменения.Они вносятся, не затрагивая части программы, непосредственно не связанные с ними. Это позволяет гарантировать, что при внесении изменений и исправлении ошибок не выйдет из строя какая-то часть программы, находящаяся в данный момент вне зоны внимания программиста."
Программирование. Разработка сверху-вниз,Снизу-вверх,"Решаются конкретные задачи, их результаты обьединяются в более крупное решение"
Программирование. Спагетти-код,Спагетти-код,"Самый распространённый антипаттерн программирования. Плохо спроектированная, слабо структурированная, запутанная и трудная для понимания программа, особенно содержащая много операторов GOTO (особенно переходов назад), исключений и других конструкций, ухудшающих структурированность. В настоящее время термин применяется не только к случаям злоупотребления GOTO, но и к любому «многосвязному» коду, в котором один и тот же небольшой фрагмент исполняется в большом количестве различных ситуаций и выполняет очень много различных логических функций. Спагетти-код может быть отлажен и работать правильно и с высокой производительностью, но он крайне сложен в сопровождении и развитии."
Программирование. Спагетти-код,Рефакторинг,"Процесс изменения внутренней структуры программы, не затрагивающий её внешнего поведения и имеющий целью облегчить понимание её работы. В основе рефакторинга лежит последовательность небольших эквивалентных (то есть сохраняющих поведение) преобразований. Поскольку каждое преобразование маленькое, программисту легче проследить за его правильностью, и в то же время вся последовательность может привести к существенной перестройке программы и улучшению её согласованности и чёткости."
"Программирование. Явный и неявный ""goto""",goto,"Оператор безусловного перехода (перехода к определённой точке программы, обозначенной номером строки либо меткой) в некоторых языках программирования. Оператор goto в языках высокого уровня является объектом критики, поскольку чрезмерное его применение приводит к созданию нечитаемого «спагетти-кода»."
"Программирование. Явный и неявный ""goto""",Оправданное применение,"Выход из вложенных циклов, обработка исключений"
"Программирование. Явный и неявный ""goto""",Неявный goto,"Фактически, циклы, условные операторы, операторы break, continue, обработка исключений ит.п. является неявными goto"
Программирование. Общие понятия о многопоточном исполнении кода,Процесс,"Совокупность кода и данных, разделяющих общее виртуальное адресное пространство. Чаще всего одна программа состоит из одного процесса, но бывают и исключения. Процессы изолированы друг от друга, поэтому прямой доступ к памяти чужого процесса невозможен (взаимодействие между процессами осуществляется с помощью специальных средств). Для каждого процесса ОС создает так называемое «виртуальное адресное пространство», к которому процесс имеет прямой доступ. Это пространство принадлежит процессу, содержит только его данные и находится в полном его распоряжении. Операционная система же отвечает за то, как виртуальное пространство процесса проецируется на физическую память."
Программирование. Общие понятия о многопоточном исполнении кода,Поток выполнения,"Наименьшая единица обработки, исполнение которой может быть назначено ядром операционной системы."
Программирование. Общие понятия о многопоточном исполнении кода,Многопоточность,"Многопоточность, как широко распространённая модель программирования и исполнения кода, позволяет нескольким потокам выполняться в рамках одного процесса. Эти потоки выполнения совместно используют ресурсы процесса, но могут работать и самостоятельно. Многопоточная модель программирования предоставляет разработчикам удобную абстракцию параллельного выполнения. Однако, пожалуй, наиболее интересное применение технологии имеется в том случае, когда она применяется к одному процессу, что позволяет его параллельное выполнение на многопроцессорной системе."
Программирование. Общие понятия о многопоточном исполнении кода,Плюсы многопоточности в программировании,"Упрощение программы в некоторых случаях за счёт использования общего адресного пространства
Меньшие относительно процесса временные затраты на создание потока
Повышение производительности процесса за счёт распараллеливания процессорных вычислений и операций ввода-вывода"
Программирование. Общие понятия о многопоточном исполнении кода,Некоторые области применения,"Программирование интерфейсов, игры ит.п."
Программирование. Общие понятия о многопоточном исполнении кода,Проблемы многопоточности,
Программирование. Общие понятия о многопоточном исполнении кода,Состязания за ресурсы,"Состязание за ресурсы может возникать в случае, если два или более потоков получают доступ к одним и тем же объектам, а доступ к совместно используемому состоянию не синхронизируется. Избежать возникновения данной проблемы можно, заблокировав разделяемый объект. "
Программирование. Общие понятия о многопоточном исполнении кода,Взаимоблокировка,"Ситуация, когда как минимум два потока останавливаются и ожидают друг от друга снятия блокировки. Поскольку оба потока ожидают друг от друга выполнения соответствующего действия, получается, что они блокируют друг друга, из-за чего их ожидание может длиться бесконечно. Практически об устранении взаимных блокировок надо заботиться ещё на этапе проектирования системы — это единственный более-менее надежный способ с ними бороться. Классический способ борьбы с проблемой — разработка иерархии блокировок, установление правила, что некоторые блокировки никогда не могут захватываться в состоянии, в котором уже захвачены какие-то другие блокировки."
Программирование. Общие понятия о многопоточном исполнении кода,Взаимодействие потоков,"В многопоточной среде часто возникают проблемы, связанные с использованием параллельно исполняемыми потоками одних и тех же данных или устройств. Для решения подобных проблем используются такие методы взаимодействия потоков, как взаимоисключения (мьютексы), семафоры, критические секции и события"
Программирование. Общие понятия о многопоточном исполнении кода,Семафор,"Объект, ограничивающий количество потоков, которые могут войти в заданный участок кода."
Программирование. Общие понятия о многопоточном исполнении кода,Применение семафоров,"Некоторые из проблем, которые могут решать семафоры:
запрет одновременного выполнения заданных участков кода (критические секции);
поочерёдный доступ к критическому ресурсу (важному ресурсу, для которого невозможен (или нежелателен) одновременный доступ);
синхронизация процессов и потоков (например, можно инициировать обработку события отпусканием семафора)."
Программирование. Общие понятия о многопоточном исполнении кода,Мьютекс (взаимоисключения),"Аналог одноместного семафора. Отличается тем, что только владеющий им поток может его освободить, т.е. перевести в отмеченное состояние."
Программирование. Общие понятия о многопоточном исполнении кода,Критическая секция,"Объект синхронизации потоков, позволяющий предотвратить одновременное выполнение некоторого набора операций (обычно связанных с доступом к данным) несколькими потоками. Критическая секция выполняет те же задачи, что и мьютекс.
Процедура входа и выхода из критических секций обычно занимает меньшее время, нежели аналогичные операции мьютекса, что связано с отсутствием необходимости обращаться к ядру ОС.
В операционных системах семейства Microsoft Windows разница между мьютексом и критической секцией в том, что мьютекс является объектом ядра и может быть использован несколькими процессами одновременно, критическая секция же принадлежит процессу и служит для синхронизации только его потоков."
Программирование. Общие понятия о многопоточном исполнении кода,События,"Объект, хранящий в себе 1 бит информации «просигнализирован или нет», над которым определены операции «просигнализировать», «сбросить в непросигнализированное состояние» и «ожидать». Ожидание на непросигнализированном событии приводит к приостановке исполнения потока до тех пор, пока другой поток (или же вторая фаза обработчика прерывания в ядре ОС) не просигнализирует событие."
Программирование. Общие понятия о многопоточном исполнении кода,Условная переменная,Обеспечивает блокирование одного или нескольких потоков до момента поступления сигнала от другого потока о выполнении некоторого условия или до истечения максимального промежутка времени ожидания.
Базы данных. Типы данных,Реляционная база данных,"Совокупность отношений (таблиц), содержащих всю информацию, которая должна храниться в БД.
Основана на реляционной модели данных"
Базы данных. Типы данных,Реляционная модель данных,"Реляционная модель данных включает следующие компоненты:
Структурный аспект — данные в базе данных представляют собой набор отношений.
Аспект целостности — отношения (таблицы) отвечают определенным условиям целостности. РМД поддерживает декларативные ограничения целостности уровня домена (типа данных), уровня отношения и уровня базы данных.
Аспект обработки (манипулирования) — РМД поддерживает операторы манипулирования отношениями (реляционная алгебра, реляционное исчисление)."
Базы данных. Типы данных,Тип данных,"Понятие тип данных в реляционной модели данных полностью адекватно понятию типа данных в языках программирования. В sql используются следующие типы:
CHAR(size) строка фикс длины, VARCHAR(size) строка 255, TEXT, ENUM(x, y, z) список значений, TINYINT -128 127, SMALLINT, MEDIUMINT, INT, FLOAT, DATE, DATETIME,  "
Базы данных. Нормализация и денормализация,Нормальная форма,"Требование, предъявляемое к структуре таблиц в теории реляционных баз данных для устранения из базы избыточных функциональных зависимостей между атрибутами (полями таблиц)."
Базы данных. Нормализация и денормализация,Нормализация,"Процесс преобразования отношений базы данных к виду, отвечающему нормальным формам"
Базы данных. Нормализация и денормализация,Функциональная зависимость,"Если даны два атрибута X и Y некоторого отношения, то говорят, что Y функционально зависит от X, если в любой момент времени каждому значению X соответствует ровно одно значение Y. Функциональная зависимость обозначается X -> Y"
Базы данных. Нормализация и денормализация,Избыточная функциональная зависимость,"Зависимость, заключающая в себе такую информацию, которая может быть получена на основе других зависимостей, имеющихся в базе данных"
Базы данных. Нормализация и денормализация,Транзитивная функциональная зависимость,"Пусть X, Y, Z - три атрибута некоторого отношения. При этом X --> Y и Y --> Z, но обратное 
соответствие отсутствует, т.е. Z -/-> Y и Y -/-> X. Тогда  Z транзитивно зависит от X. "
Базы данных. Нормализация и денормализация,Многозначная зависимость ,Является обобщением функциональной зависимости и рассматривает соответствия между множествами значений атрибутов
Базы данных. Нормализация и денормализация,Зависимости по соединению,"Существуют отношения, для которых нельзя выполнить декомпозицию без потерь на две проекции, но которые можно подвергнуть декомпозиции без потерь на три (или более) проекций. Этот факт получил название зависимости по соединению, а такие отношения называют 3-декомпозируемые отношения"
Базы данных. Нормализация и денормализация,Ограничение домена,"Ограничение, предписывающее использовать для определённого атрибута значения только из некоторого заданного домена. Ограничение по своей сути является заданием перечня (или логического эквивалента перечня) допустимых значений типа и объявлением о том, что указанный атрибут имеет данный тип."
Базы данных. Нормализация и денормализация,Ограничение ключа,"Ограничение, утверждающее, что некоторый атрибут или комбинация атрибутов является потенциальным ключом"
Базы данных. Нормализация и денормализация,Первая нормальная форма 1NF,"Отношение находится в 1НФ, если все его атрибуты являются простыми, все используемые домены должны содержать только скалярные значения. Не должно быть повторений строк в таблице.
Пример - если в таблице одному сотруднику сопоставлены 2 номера телефонов. Необходимо разделить на 2 строки"
Базы данных. Нормализация и денормализация,Вторая нормальная форма 2NF,"Отношение находится во 2НФ, если оно находится в 1НФ и каждый неключевой атрибут функционально полно зависит от ключа, т.е. функционально зависит от всего ключа в целом, но не находится в функциональной зависимости от какого-либо из входящих в него атрибутов. 
Пример - если в таблице зарплата зависит от филиала и должности, а наличине компьютера только от должности - необходимо создать второе отношение(таблицу) должность-компьютер, убрав компьютер из первой."
Базы данных. Нормализация и денормализация,Третья нормальная форма 3NF,"Отношение находится в 3НФ, когда находится во 2НФ и каждый не ключевой атрибут нетранзитивно зависит от потенциального ключа. Проще говоря, каждый неключевой атрибут «должен предоставлять информацию о ключе, полном ключе и ни о чём, кроме ключа.
Пример - если в таблице есть сотрудник, отдел и телефон отдела - возникают следующие зависимости - сотрудник->отдел, отдел->телефон, сотрудник->телефон. Зависимость сотрудник->телефон является транзитивной, следовательно отношение не находится в 3NF, необходимо вынести отдел-телефон в новую таблицу, убрав телефон из первой"
Базы данных. Нормализация и денормализация,"Нормальная форма Бойса-Кодда (частная, более строгая, форма 3NF) BCNF","Отношение находится в BCNF, если оно находится во 3НФ и в ней отсутствуют зависимости атрибутов первичного ключа от неключевых атрибутов.
Ситуация, когда отношение будет находится в 3NF, но не в BCNF, возникает при условии, что отношение имеет два (или более) возможных ключа, которые являются составными и имеют общий атрибут. Заметим, что на практике такая ситуация встречается достаточно редко, для всех прочих отношений 3NF и BCNF эквивалентны.
Пример - если в таблице есть номер корта, время начала, время окончания, тариф (вида ""корт1 для членов клуба"") то возможны следюущие составные первичные ключи {Номер корта, Время начала}, {Номер корта, Время окончания}, {Тариф, Время начала}, {Тариф, Время окончания}. Существует функциональная зависимость Тариф → Номер корта, в которой левая часть (детерминант) не является потенциальным ключом отношения, то есть отношение не находится в нормальной форме Бойса — Кодда. Необходимо вынести в новую таблицу тариф-номер корта, убрав номер корта из первой таблицы"
Базы данных. Нормализация и денормализация,Четвёртая нормальная форма 4NF,"Отношение находится в 4NF если оно находится в BCNF и в нем отстутсвуют многозначные зависимости, не являющиеся функциональными зависимостями.
Пример - составной первичный ключ включает три атрибута: {Ресторан, Вид пиццы, Район доставки}. Такая переменная отношения не соответствует 4НФ, так как существует следующая многозначная зависимость: ресторан->вид пиццы и ресторан->район доставки
То есть, например, при добавлении нового вида пиццы придется внести по одному новому кортежу для каждого района доставки. Возможна логическая аномалия, при которой определенному виду пиццы будут соответствовать лишь некоторые районы доставки из обслуживаемых рестораном районов.
Для предотвращения аномалии нужно декомпозировать отношение, разместив независимые факты в разных отношениях. В данном примере необходимо вынести в новую таблицу ресторан-район доставки."
Базы данных. Нормализация и денормализация,Пятая нормальная форма 5NF,"Отношение находится в 5НФ тогда и только тогда, когда любая зависимость по соединению в нем определяется только его возможными ключами.
Другими словами, каждая проекция такого отношения содержит не менее одного возможного ключа и не менее одного неключевого атрибута. 
Пример -Предположим, что продавец может торговать продукцией нескольких фирм, ассортимент у фирм различен, причем продавец может предлагать только часть товаров конкретной фирмы. Отношение {Продавец, Фирма, Вид товара} соответствует 4NF, однако не отражает ограничения, связанного с ассортиментом продукции фирм. Может возникнуть кортеж, в котором фирме будет соответствовать вид товара, который она не выпускает. В данном случае (для приведения к 5NF) отношение должно быть разбито на три: {Продавец, Фирма}, {Фирма, Вид товара}, {Продавец, Вид товара}."
Базы данных. Нормализация и денормализация,Доменно-ключевая нормальная форма DKNF,"Переменная отношения находится в ДКНФ тогда и только тогда, когда каждое наложенное на неё ограничение является логическим следствием ограничений доменов и ограничений ключей, наложенных на данную переменную отношения.
Любая переменная отношения, находящаяся в ДКНФ, обязательно находится в 5НФ. Однако не любую переменную отношения можно привести к ДКНФ."
Базы данных. Нормализация и денормализация,Шестая нормальная форма 6NF,"Переменная отношения находится в шестой нормальной форме тогда и только тогда, когда она удовлетворяет всем нетривиальным зависимостям соединения. Из определения следует, что переменная находится в 6НФ тогда и только тогда, когда она неприводима, то есть не может быть подвергнута дальнейшей декомпозиции без потерь. Каждая переменная отношения, которая находится в 6НФ, также находится и в 5НФ."
Базы данных. Нормализация и денормализация,Денормализация,"Намеренное приведение структуры базы данных в состояние, не соответствующее критериям нормализации, обычно проводимое с целью ускорения операций чтения из базы за счет добавления избыточных данных."
Базы данных. Нормализация и денормализация,Причины использования,"При запросах большого количества данных операция соединения нормализованных отношений выполняется неприемлемо долго. Вследствие этого в ситуациях, когда производительность таких запросов невозможно повысить иными средствами, может проводиться денормализация — композиция нескольких отношений (таблиц) в одну, которая, как правило, находится во второй, но не в третьей нормальной форме. Новое отношение фактически является хранимым результатом операции соединения исходных отношений."
Базы данных. Ключи,Потенциальный ключ,"Подмножество атрибутов отношения, удовлетворяющее требованиям уникальности и минимальности (несократимости).
Уникальность -  нет и не может быть двух кортежей данного отношения, в которых значения этого подмножества атрибутов совпадают
Минимальность  - в составе потенциального ключа отсутствует меньшее подмножество атрибутов, удовлетворяющее условию уникальности. Иными словами, если из потенциального ключа убрать любой атрибут, он утратит свойство уникальности."
Базы данных. Ключи,Первичный ключ,"В реляционной модели данных один из потенциальных ключей отношения, выбранный в качестве основного ключа (или ключа по умолчанию)
Если первичный ключ состоит из единственного атрибута, его называют простым ключом.
Если первичный ключ состоит из двух и более атрибутов, его называют составным ключом."
Базы данных. Ключи,Естественный ключ,"Первичный ключ может состоять из информационных полей таблицы (то есть полей, содержащих полезную информацию об описываемых объектах). Такой первичный ключ называют естественным ключом (или интеллектуальным)"
Базы данных. Ключи,Суррогатный ключ,"Дополнительное служебное поле, добавленное к уже имеющимся информационным полям таблицы, единственное предназначение которого — служить первичным ключом. Значение этого поля не образуется на основе каких-либо других данных из БД, а генерируется искусственно.
Плюсы - неизменность, гарантированная уникальность, гибкость, эффективность
Минусы - неинформативность, вопросы оптимизации"
Базы данных. Ключи,Внешний ключ,"Определяет  связь поля с другой таблицей, для которой этот ключ является первичным.
Пример - города c ID и улицы с ID_city являющимся внешним ключом и ссылающимся на таблицу CITY"
Базы данных. Ключи,Суперключ," Подмножество атрибутов отношения, удовлетворяющее требованию уникальности. Суперключ отличается от потенциального ключа тем, что на суперключ не накладывается требование минимальности. Таким образом, потенциальный ключ может быть определён как суперключ, обладающий свойством минимальности (несократимости)."
Базы данных. Домены,Домен (базы данных),"Допустимое потенциальное, ограниченное подмножество значений данного типа.
Пример - домен ИМЕНА определен на базовом типе символьных строк, но в число его значений могут входить только те строки, которые могут представлять имена (в частности, для возможности представления русских имен такие строки не могут начинаться с мягкого или твердого знака и не могут быть длиннее, например, 20 символов)
Следует отметить также семантическую нагрузку понятия домена: данные считаются сравнимыми только в том случае, когда они относятся к одному домену. В нашем примере значения доменов НОМЕРА ПРОПУСКОВ и НОМЕРА ОТДЕЛОВ относятся к типу целых чисел, но не являются сравнимыми (допускать их сравнение было бы бессмысленно)"
Базы данных. Блокировки. Транзакции,Целостное состояние БД,"Любая база данных годна к использованию только тогда, когда ее состояние соответствует состоянию предметной области. Такие состояния называют целостными. Очевидно, что при изменении данных БД должна переходить от одного целостного состояния к другому. Однако, в процессе обновления данных возможны ситуации, когда состояние целостности нарушается.
Пример - перевод денег с одного счета на другой производится за 2 операции, и если произойдет сбой между ними - целостное состояние БД будет утеряно"
Базы данных. Блокировки. Транзакции,Транзакция,"Последовательность операций, которые должны быть или все выполнены или все не выполнены"
Базы данных. Блокировки. Транзакции,ACID,"ACID описывает требования к транзакционной системе - атомарность, согласованность, изолированность, долговечность"
Базы данных. Блокировки. Транзакции,Проблемы одновременного выполнения нескольких транзакций,"Грязное чтение - транзакция Т1 модифицировала некий элемент данных. После этого другая транзакция Т2 прочитала содержимое этого элемента данных до завершения транзакции Т1. Если Т1 заврешается операцией ROLLBACK(откат в SQL), то получается, что транзакция Т2 прочитала не существующие данные.
Неповторяемое (размытое) чтение - транзакция Т1 прочитала содержимое элемента данных. После этого другая транзакция Т2 модифицировала или удалила этот элемент. Если Т1 прочитает содержимое этого элемента занова, то она получит другое значение или обнаружит, что элемент данных больше не существует.
Фантом (фиктивные элементы) - транзакция Т1 прочитала содержимое нескольких элементов данных, удовлетворяющих некому условию. После этого Т2 создала элемент данных, удовлетворяющий этому условию и зафиксировалась. Если Т1 повторит чтение с тем же условием, она получит другой набор данных."
Базы данных. Блокировки. Транзакции,Сериализуемость параллельной обработки транзакций,"Чередующееся (параллельное) выполнение заданного множества транзакций будет верным, если при его выполнении будет получен такой же результат, как и при последовательном выполнении тех же транзакций."
Базы данных. Блокировки. Транзакции,Механизм блокировок,"Обеспечивает принудительное упорядочение транзакций.  Если для выполнения некоторой транзакции необходимо, чтобы некоторый объект базы данных (кортеж, набор кортежей, отношение, набор отношений,..) не изменялся непредсказуемо и без ведома этой транзакции, такой объект блокируется."
Базы данных. Блокировки. Транзакции,Виды блокировок,"блокировка со взаимным доступом, называемая также S-блокировкой (от Shared locks) и блокировкой по чтению.
монопольная блокировка (без взаимного доступа), называемая также X-блокировкой от (eXclusive locks) или блокировкой по записи. Этот режим используется при операциях изменения, добавления и удаления объектов.
Если транзакция налагает на объект X-блокировку, то любой запрос другой транзакции с блокировкой этого объекта будет отвергнут.
если транзакция налагает на объект S-блокировку, то
запрос со стороны другой транзакции с X-блокировокй на этот объект будет отвергнут
запрос со стороны другой транзакции с S-блокировокй этого объекта будет принят"
Базы данных. Структура БД,Схема(структура) базы данных,"Схема базы данных (от англ. Database schema) — её структура, описанная на формальном языке, поддерживаемом СУБД. В реляционных базах данных схема определяет таблицы, поля в каждой таблице (обычно с указанием их названия, типа, обязательности), и ограничения целостности (первичный, потенциальные и внешние ключи и другие ограничения)."
Базы данных. Построение БД,Проектирование баз данных,Процесс создания схемы базы данных и определения необходимых ограничений целостности.
Базы данных. Построение БД,Целостность базы данных,"Соответствие имеющейся в базе данных информации её внутренней логике, структуре и всем явно заданным правилам."
Базы данных. Построение БД,Ограничение целостности,"Каждое правило, налагающее некоторое ограничение на возможное состояние базы данных
Ограничением базы данных называется ограничение на значения, которые разрешено принимать указанной базе данных.
Ограничением переменной отношения называется ограничение на значения, которые разрешено принимать указанной переменной отношения.
Ограничением атрибута называется ограничение на значения, которые разрешено принимать указанному атрибуту.
Ограничение типа представляет собой не что иное, как определение множества значений, из которых состоит данный тип."
Базы данных. Построение БД,Основные задачи проектирования баз данных,"Обеспечение хранения в БД всей необходимой информации.
Обеспечение возможности получения данных по всем необходимым запросам.
Сокращение избыточности и дублирования данных.
Обеспечение целостности базы данных."
Базы данных. Построение БД,Основные этапы проектирования баз данных,
Базы данных. Построение БД,Концептуальное проектирование,"Построение семантической модели предметной области, то есть информационной модели наиболее высокого уровня абстракции. (например ER-модель). Такая модель создаётся без ориентации на какую-либо конкретную СУБД и модель данных.Чаще всего концептуальная модель базы данных включает в себя:
описание информационных объектов или понятий предметной области и связей между ними.
описание ограничений целостности, то есть требований к допустимым значениям данных и к связям между ними."
Базы данных. Построение БД,Логическое проектирование,"Создание схемы базы данных на основе конкретной модели данных, например, реляционной модели данных. Для реляционной модели данных даталогическая модель — набор схем отношений, обычно с указанием первичных ключей, а также «связей» между отношениями, представляющих собой внешние ключи.
Преобразование концептуальной модели в логическую модель, как правило, осуществляется по формальным правилам. Этот этап может быть в значительной степени автоматизирован. На этапе логического проектирования учитывается специфика конкретной модели данных, но может не учитываться специфика конкретной СУБД."
Базы данных. Построение БД,Физическое проектирование,"Создание схемы базы данных для конкретной СУБД. Специфика конкретной СУБД может включать в себя ограничения на именование объектов базы данных, ограничения на поддерживаемые типы данных и т. п. Кроме того, специфика конкретной СУБД при физическом проектировании включает выбор решений, связанных с физической средой хранения данных (выбор методов управления дисковой памятью, разделение БД по файлам и устройствам, методов доступа к данным), создание индексов и т. д."
Базы данных. Построение БД,Модель «сущность-связь» ER-модель,"Наиболее известный представитель класса семантических моделей предметной области. Она определяет значения данных в контексте их взаимосвязи с другими данными. Любой фрагмент предметной области может быть представлен как множество сущностей, между которыми существует некоторое множество связей.
Сущность - это объект, который может быть идентифицирован неким способом, отличающим его от других объектов (конкретный человек, предприятие, событие)
Набор сущностей - множество сущностей одного типа (обладающих одинаковыми свойствами). Примеры: все люди, предприятия, праздники и т.д. Наборы сущностей не обязательно должны быть непересекающимися. Например, сущность, принадлежащая к набору МУЖЧИНЫ, также принадлежит набору ЛЮДИ.
Сущность фактически представляет из себя множество атрибутов, которые описывают свойства всех членов данного набора сущностей.
Пример - рассмотрим множество работников некого предприятия. Каждого из них можно описать с помощью характеристик табельный номер, имя, возраст. Поэтому, сущность СОТРУДНИК имеет атрибуты ТАБЕЛЬНЫЙ_НОМЕР, ИМЯ, ВОЗРАСТ."
Базы данных. SQL (плюс - аналитические и агрегатные функции),SQL,"Structured query language (язык структурированных запросов) - формальный непроцедурный язык программирования, применяемый для создания, модификации и управления данными в произвольной реляционной базе данных, управляемой соответствующей системой управления базами данных (СУБД)"
Базы данных. SQL (плюс - аналитические и агрегатные функции),Типы данных SQL,"Все допустимые в SQL типы данных, которые можно использовать при определении столбцов, разбиваются на следующие категории:
точные числовые типы (exact numerics); приближенные числовые типы (approximate numerics); типы символьных строк (character strings) ;типы битовых строк (bit strings); типы даты и времени (datetimes); типы временных интервалов (intervals); булевский тип (Booleans); типы коллекций (collection types); анонимные строчные типы (anonymous row types); типы, определяемые пользователем (user-defined types); ссылочные типы (reference types)."
Базы данных. SQL (плюс - аналитические и агрегатные функции),операторы определения данных,
Базы данных. SQL (плюс - аналитические и агрегатные функции),CREATE,"Создает объект БД (саму базу, таблицу, представление, пользователя и т. д.)
CREATE ASSERTION — создание утверждения
CREATE CHARACTER SET — создание набора символов
CREATE COLLATION — создание правила сортировки для набора символов
CREATE DOMAIN — создание домена (пользовательского типа данных столбца).
CREATE SCHEMA — создание схемы (именованной группы объектов)
CREATE TABLE — создание таблицы базы данных
CREATE TRANSLATION — создание правила преобразования (трансляции) из одного набора символов в другой (используется в операторе TRANSLATE)
CREATE VIEW — создание представления данных
 CREATE TABLE Student (
   Code integer NOT NULL,
   Name char (30) NOT NULL ,
   Address char (50),
   Mark decimal
 );"
Базы данных. SQL (плюс - аналитические и агрегатные функции),ALTER,Изменяет объект
Базы данных. SQL (плюс - аналитические и агрегатные функции),DROP,Удаляет объект
Базы данных. SQL (плюс - аналитические и агрегатные функции),операторы манипуляции данными,
Базы данных. SQL (плюс - аналитические и агрегатные функции),SELECT,"Возвращает набор данных (выборку) из базы данных, удовлетворяющих заданному условию.
SELECT список полей FROM список таблиц WHERE условия…
Основные ключевые слова, относящиеся к запросу SELECT:
WHERE — используется для определения, какие строки должны быть выбраны или включены в GROUP BY.
GROUP BY — используется для объединения строк с общими значениями в элементы меньшего набора строк.
HAVING — используется для определения, какие строки после GROUP BY должны быть выбраны.
ORDER BY — используется для определения, какие столбцы используются для сортировки результирующего набора данных.
SELECT * FROM T WHERE C1 = 1;"
Базы данных. SQL (плюс - аналитические и агрегатные функции),INSERT,"Позволяет добавить строки в таблицу, заполняя их значениями. Значения можно вставлять перечислением с помощью слова values и перечислив их в круглых скобках через запятую или оператором select.
insert into <название таблицы> ([<Имя столбца>, ... ]) values (<Значение>,...)
insert into <название таблицы> select <имя столбца>,... from <название таблицы>"
Базы данных. SQL (плюс - аналитические и агрегатные функции),UPDATE,"Позволяет обновить значения в заданных столбцах таблицы.
UPDATE [top(x)] <объект> 
SET <присваивание1 [, присваивание2, ...]> 
[WHERE <условие>];
top(x) — команда выполнится только х раз
<объект> — объект, над которым выполняется действие (таблица или представление)
<присваивание> — присваивание, которое будет выполняться при каждом выполнении условия <условие>, или для каждой записи, если отсутствует раздел where
<условие> — условие выполнения команды
SET — после ключевого слова должен идти список полей таблицы, которые будут обновлены и непосредственно сами новые значения в виде
имя поля=""значение""
UPDATE tbl_books SET price = 0 WHERE quantity = 0;"
Базы данных. SQL (плюс - аналитические и агрегатные функции),,"Операция удаления записей из таблицы
DELETE FROM <Имя Таблицы> WHERE <Условие отбора записей>"
Базы данных. SQL (плюс - аналитические и агрегатные функции),операторы определения доступа к данным,
Базы данных. SQL (плюс - аналитические и агрегатные функции),GRANT,Предоставляет пользователю (группе) разрешения на определенные операции с объектом
Базы данных. SQL (плюс - аналитические и агрегатные функции),REVOKE,Отзывает ранее выданные разрешения
Базы данных. SQL (плюс - аналитические и агрегатные функции),DENY,"Задает запрет, имеющий приоритет над разрешением"
Базы данных. SQL (плюс - аналитические и агрегатные функции),операторы управления транзакциями,
Базы данных. SQL (плюс - аналитические и агрегатные функции),COMMIT,"Оператор управления транзакциями для успешного завершения транзакции. При выполнении оператора изменения, сделанные от начала транзакции и ранее не видимые для других транзакций, фиксируются в базе данных
BEGIN TRANSACTION WORK;
 INSERT INTO MyTable VALUES ('50', 'some string');
 COMMIT WORK;"
Базы данных. SQL (плюс - аналитические и агрегатные функции),ROLLBACK,"оператор языка SQL, который применяется для того, чтобы:
отменить все изменения, внесённые начиная с момента начала транзакции или с какой-то точки сохранения (SAVEPOINT);
очистить все точки сохранения данной транзакции;
завершить транзакцию;
освободить все блокировки данной транзакции.
BEGIN TRANSACTION WORK;
INSERT INTO MyTable VALUES ('50', 'some string');
ROLLBACK WORK;"
Базы данных. SQL (плюс - аналитические и агрегатные функции),SAVEPOINT,Делит транзакцию на более мелкие участки
Базы данных. SQL (плюс - аналитические и агрегатные функции),Агрегатные функции,"Агрегатные функции предназначены для того, чтобы вычислять некоторое значение для заданного мультимножества строк. Агрегатная функция возвращает 1 результирующую строку, которая основана на группе строк.
AVG() Среднее значение агрумента
BIT_AND() Битовое и
BIT_OR() Битовое  или
BIT_XOR() Битовое исключающее или
COUNT(DISTINCT) Количество неповторяемых значений
COUNT() Количество возвращенных строк
GROUP_CONCAT() Конкатенированная строка
MAX() Максимальное значение
MIN() Минимальное значение
SUM() Сумма"
Базы данных. SQL (плюс - аналитические и агрегатные функции),Аналитические функции,"Аналитические функции вычисляют агрегированное значение, основанное на группе строк. ОТЛИЧИЕ агрегатной от аналитической функции - аналитическая функция возвращает не 1 строку результата для группы, а множество строк для группы.
ИМЯ_ФУНКЦИИ(<аргумент>,< аргумент >, . . . )
OVER
(<конструкция_фрагментации> <конструкция_упорядочения> <конструкция_окна>)
OVER — ключевое слово, идентифицирующее эту функцию как аналитическую.Конструкция после ключевого слова OVER описывает срез данных, по которому будет вычисляться аналитическая функция.
PARTITION BY логически разбивает результирующее множество на группы по критериям, задаваемым выражениями секционирования. Аналитические функции применяются к каждой группе независимо, — для каждой новой группы они сбрасываются. Если не указать конструкцию секционирования, все результирующее множество считается одной группой.
ORDER BY задает критерий сортировки данных в каждой группе (в каждой секции)
SELECT empno, deptno, sal,
       AVG(sal) OVER (PARTITION BY deptno) AS avg_dept_sal
FROM   emp;"
Базы данных. Оптимизация производительности,Производительность,"Для оптимальной производительности запросов индексы обычно создаются на тех столбцах таблицы, которые часто используются в запросах. Для одной таблицы может быть создано несколько индексов. Однако увеличение числа индексов замедляет операции добавления, обновления, удаления строк таблицы, поскольку при этом приходится обновлять сами индексы. Кроме того, индексы занимают дополнительный объем памяти, поэтому перед созданием индекса следует убедиться, что планируемый выигрыш в производительности запросов превысит дополнительную затрату ресурсов компьютера на сопровождение индекса."
Базы данных. Оптимизация производительности,Индексирование,"Зачительно убыстряет SELECT запросы, однако индексы занимают дополнительную память и периодически должны быть перестроены. Оптимальное решение сложно найти, поэтому разработчики и администраторы баз данных тратят много времени на поиск золотой середины, к тому же индексы необходимо реорганизовывать."
Базы данных. Оптимизация производительности,Скорость работы индексов,"Внешние ключи желательно индексировать, это грозит значительным повышением производительности;
Отдельно проиндексированные столбцы текста, даты, чисел повышают скорость запросов;
Индексы лучше работают с таблицами, содержащими большое количество строк;
Индексы лучше работают при выборке большого количества строк;
Индексы слабо работают с вычисляемыми столбцами;
В объединяющих запросах необходимо индексировать внешний ключ и столбец, по которому будет происходить поиск;
Индекс не поможет, если конструкция WHERE содержит условия поиска для двух таблиц;
На скорость вставки данных индексы не влияют."
Базы данных. Индексы,Индекс,"Объект базы данных, создаваемый с целью повышения производительности поиска данных. Таблицы в базе данных могут иметь большое количество строк, которые хранятся в произвольном порядке, и их поиск по заданному критерию путём последовательного просмотра таблицы строка за строкой может занимать много времени. Индекс формируется из значений одного или нескольких столбцов таблицы и указателей на соответствующие строки таблицы и, таким образом, позволяет искать строки, удовлетворяющие критерию поиска. Ускорение работы с использованием индексов достигается в первую очередь за счёт того, что индекс имеет структуру, оптимизированную под поиск."
Базы данных. Индексы,Кластерные индексы,При наличии кластерного индекса строки таблицы упорядочены по значению ключа этого индекса.
Базы данных. Индексы,Некластерные индексы,"Если в таблице нет кластерного индекса, таблица называется кучей. Некластерный индекс, созданный для такой таблицы, содержит только указатели на записи таблицы. Кластерный индекс может быть только одним для каждой таблицы, но каждая таблица может иметь несколько различных некластерных индексов, каждый из которых определяет свой собственный порядок следования записей."
Базы данных. Индексы,Разрежённый индекс,"Каждый ключ в разрежённом индексе, в отличие от плотного индекса, ассоциируется с определённым указателем на блок в сортированном файле данных. Идея использования индексов пришла оттого, что современные базы данных слишком массивны и не помещаются в основную память. Мы обычно делим данные на блоки и размещаем данные в памяти поблочно. Однако поиск записи в БД может занять много времени. С другой стороны, файл индексов или блок индексов намного меньше блока данных и может поместиться в буфере основной памяти, что увеличивает скорость поиска записи. Поскольку ключи отсортированы, можно воспользоваться бинарным поиском. В кластерных индексах с дублированными ключами разрежённый индекс указывает на наименьший ключ в каждом блоке."
Базы данных. Индексы,Плотный индекс,"Каждый ключ в плотном индексе, в отличие от разреженного индекса, ассоциируется с определённым указателем на запись в сортированном файле данных"
Базы данных. Хранимые процедуры и триггеры,Хранимые процедуры,"Как правило, мы в работе с БД используем одни и те же запросы, либо набор последовательных запросов. Хранимые процедуры позволяют объединить последовательность запросов и сохранить их на сервере."
Базы данных. Хранимые процедуры и триггеры,Пример,"CREATE PROCEDURE ins_cust(n CHAR(50), e CHAR(50))
     begin
        insert into customers  (name, email) value (n, e);                                                   процедура по добавлению поставщика
     end

call ins_cust('Сычов Валерий', 'valera@gmail.ru')                                                        вызов процедуры"
Базы данных. Хранимые процедуры и триггеры,Триггер," Хранимая процедура особого типа, которую пользователь не вызывает непосредственно, а исполнение которой обусловлено действием по модификации данных. Триггеры применяются для обеспечения целостности данных и реализации сложной бизнес-логики. Триггер запускается сервером автоматически при попытке изменения данных в таблице, с которой он связан. Все производимые им модификации данных рассматриваются как выполняемые в транзакции, в которой выполнено действие, вызвавшее срабатывание триггера. Соответственно, в случае обнаружения ошибки или нарушения целостности данных может произойти откат этой транзакции."
Базы данных. Хранимые процедуры и триггеры,Типы триггеров,"Триггеры BEFORE, AFTER и INSTEAD OF - выполняются до выполнения операции обновления базовой таблицы/после/вместо
Триггеры INSERT, UPDATE и DELETE - указывает на природу события, вызвавшего триггер
Триггеры ROW и STATEMENT- FOR EACH ROW-триггер будет вызываться для каждой строки обновляемой таблицы, FOR EACH STATEMENT-один раз для всего процесса"
Базы данных. Хранимые процедуры и триггеры,Пример,"INSERT INTO Сделка 
  VALUES (3,1,-299,'01/08/2002')

триггер для отмены команды в случае если недостаточно товара
CREATE TRIGGER Триггер_ins
ON Сделка FOR INSERT
AS
IF @@ROWCOUNT=1
BEGIN
  IF NOT EXISTS(SELECT *
      FROM inserted
      WHERE -inserted.количество<=ALL(SELECT
        Склад.Остаток
    FROM Склад,Сделка
    WHERE Склад.КодТовара=
      Сделка.КодТовара))
    BEGIN
      ROLLBACK TRAN
    PRINT 
     'Отмена поставки: товара на складе нет'
    END
END"
Базы данных. Права доступа,Пользователи,"Каждый пользователь в среде SQL, имеет специальное идентификационное имя или номер."
Базы данных. Права доступа,Предоставление привилегий,"GRANT SELECT, INSERT ON Orders TO USER1, USER2;                         дать права на селект и инсерт в таблице orders юзеру1 и юзеру2
GRANT ALL ON Customers TO USER1;                                                    дать все права в таблице customers юзеру1
GRANT UPDATE (COL1, COL2) ON Customers TO USER2;                   дать права на апдейт столбцов COL1 и COL2 в таблице customers юзеру2
GRANT SELECT ON Customers TO PUBLIC;                                            дать права на селект в таблице customers всем
GRANT INSERT ON Orders TO USER1 WITH GRANT OPTION;            дать права с возможностью передачи прав"
Базы данных. Права доступа,Отмена привилегий,REVOKE INSERT ON Orders FROM USER1;                                          забрать права на инсерт в таблице orders у юзера1
Базы данных. Права доступа,Запрет действий,DENY SELECT ON Orders TO USER1;
Коллекции (а так же хэшированные наборы данных),Хэширование ," Преобразование массива входных данных произвольной длины в (выходную) битовую строку фиксированной длины, выполняемое определённым алгоритмом."
Коллекции (а так же хэшированные наборы данных),Хэш-таблица," Структура данных, реализующая интерфейс ассоциативного массива, а именно, она позволяет хранить пары (ключ, значение) и выполнять три операции: операцию добавления новой пары, операцию поиска и операцию удаления пары по ключу."
Коллекции (а так же хэшированные наборы данных),Использование хэширования,"Хеширование применяется в следующих случаях:
при построении словарей;
при поиске дубликатов в сериях наборов данных;
при построении уникальных идентификаторов для наборов данных;
при вычислении контрольных сумм от данных (сигнала) для последующего обнаружения в них ошибок (возникших случайно или внесённых намеренно), возникающих при хранении и/или передаче данных;
при сохранении паролей в системах защиты в виде хеш-кода (для восстановления пароля по хеш-коду требуется функция, являющаяся обратной по отношению к использованной хеш-функции);
при выработке электронной подписи (на практике часто подписывается не само сообщение, а его «хеш-образ»);"
"Базовые знания и опыт составления, применения и оптимизации алгоритмов",Алгоритм,"Точное предписание, однозначно определяющее вычислительный процесс, ведущий от варьируемых начальных данных к искомому результату"
"Базовые знания и опыт составления, применения и оптимизации алгоритмов",Сложность алгоритма,"При разработке алгоритмов очень важно иметь возможность оценить ресурсы, необходимые для проведения вычислений. Оцениваемым ресурсом чаще всего является процессорное время (вычислительная сложность) и память (сложность алгоритма по памяти). Оценка позволяет предсказать время выполнения и сравнивать эффективность алгоритмов."
"Базовые знания и опыт составления, применения и оптимизации алгоритмов",Подсчет выполняемых операций,"Точное количество операций будет зависеть от обрабатываемых данных, поэтому имеет смысл говорить о наилучшем, наихудшем и среднем случаях. При этом худшему случаю всегда уделяется особое внимание, в том числе потому, что «плохие» данные могут быть намеренно поданы на вход злоумышленником.
Понятие среднего случая используется для оценки поведения алгоритма с расчетом на то, что наборы данных равновероятны."
"Базовые знания и опыт составления, применения и оптимизации алгоритмов",Асимптотический анализ алгоритмов,"Одним из упрощенных видов анализа, используемых на практике, является асимптотический анализ алгоритмов. Целью асимптотического анализа является сравнение затрат времени и других ресурсов различными алгоритмами, предназначенными для решения одной и той же задачи, при больших объемах входных данных.
«почистить ковёр пылесосом» требует время, линейно зависящее от его площади ( {\displaystyle \Theta (A)} \Theta (A)), то есть на ковёр, площадь которого больше в два раза, уйдет в два раза больше времени. Соответственно, при увеличении площади ковра в сто тысяч раз объём работы увеличивается строго пропорционально в сто тысяч раз, и т. п.
«найти имя в телефонной книге» требует всего лишь времени, логарифмически зависящего от количества записей ( {\displaystyle O(\log _{2}(n))} O(\log _{2}(n))), так как, открыв книгу примерно в середине, мы уменьшаем размер «оставшейся проблемы» вдвое (за счет сортировки имен по алфавиту). Таким образом, в книге объёмом в 1000 страниц любое имя находится не больше, чем за {\displaystyle \log _{2}1000\approx 10} \log _{2}1000\approx 10 раз (открываний книги). При увеличении объёма страниц до ста тысяч проблема все ещё решается за {\displaystyle \log _{2}100000\approx 17} \log _{2}100000\approx 17 заходов. (См. Двоичный поиск.)"
"Знание основ технологии взаимодействия приложения с БД (JBDC, ODBC, ADO и т.д.). Выполнение простых запросов, обработка результатов",ODBC (Open Database Connectivity),"Программный интерфейс (API) доступа к базам данных. C помощью ODBC прикладные программисты могли разрабатывать приложения для использования одного интерфейса доступа к данным, не беспокоясь о тонкостях взаимодействия с несколькими источниками."
"Знание основ технологии взаимодействия приложения с БД (JBDC, ODBC, ADO и т.д.). Выполнение простых запросов, обработка результатов",JDBC (Java DataBase Connectivity — соединение с базами данных на Java),"Платформенно-независимый промышленный стандарт взаимодействия Java-приложений с различными СУБД, реализованный в виде пакета java.sql, входящего в состав Java SE.
JDBC основан на концепции так называемых драйверов, позволяющих получать соединение с базой данных по специально описанному URL. Драйверы могут загружаться динамически (во время работы программы). Загрузившись, драйвер сам регистрирует себя и вызывается автоматически, когда программа требует URL, содержащий протокол, за который драйвер отвечает."
"Знание основ технологии взаимодействия приложения с БД (JBDC, ODBC, ADO и т.д.). Выполнение простых запросов, обработка результатов",Преимущества,"Лёгкость разработки: разработчик может не знать специфики базы данных, с которой работает;
Код практически не меняется, если компания переходит на другую базу данных (количество изменений зависит исключительно от различий между диалектами SQL);
Не нужно устанавливать громоздкую клиентскую программу;
К любой базе можно подсоединиться через легко описываемый URL."
"Знание основ технологии взаимодействия приложения с БД (JBDC, ODBC, ADO и т.д.). Выполнение простых запросов, обработка результатов",ADO (ActiveX Data Objects,"Интерфейс программирования приложений для доступа к данным, разработанный компанией Microsoft (MS Access, MS SQL Server) и основанный на технологии компонентов ActiveX. ADO позволяет представлять данные из разнообразных источников (реляционных баз данных, текстовых файлов и т. д.) в объектно-ориентированном виде."
"Знание основ технологии взаимодействия приложения с БД (JBDC, ODBC, ADO и т.д.). Выполнение простых запросов, обработка результатов",ADOdb,"Программная библиотека, обеспечивающая прикладной интерфейс доступа к базам данных для языков программирования PHP и Python, основанная на некоторых концепциях Microsoft ActiveX Data Objects.
import adodb
conn = adodb.NewADOConnection('mysql://user:pwd@server/db')
cursor = conn.Execute('select * from table')
for row in cursor:
 print row"
Отладка кода,Отладка,"Этап разработки, на котором обнаруживают, локализуют и устраняют ошибки. Чтобы понять, где возникла ошибка, приходится:
узнавать текущие значения переменных;
выяснять, по какому пути выполнялась программа.
Существуют две взаимодополняющие технологии отладки."
Отладка кода,Использование отладчиков,"Программ, которые включают в себя пользовательский интерфейс для пошагового выполнения программы: оператор за оператором, функция за функцией, с остановками на некоторых строках исходного кода или при достижении определённого условия."
Отладка кода,Вывод текущего состояния программы," с помощью расположенных в критических точках программы операторов вывода — на экран, принтер, громкоговоритель или в файл. Вывод отладочных сведений в файл называется журналированием."
Отладка кода,Инструменты отладки,"Профилировщики. Они позволят определить, сколько времени выполняется тот или иной участок кода. Анализ покрытия позволяет выявить неисполняемые участки кода.
API логгеры позволяют отследить взаимодействие программы и Windows API при помощи записи сообщений Windows в лог.
Дизассемблеры позволяют посмотреть ассемблерный код исполняемого файла
Снифферы помогут отследить сетевой трафик, генерируемый программой
Снифферы аппаратных интерфейсов позволяют увидеть данные, которыми обмениваются система и устройство.
Логи системы."
Отладка кода,"Инструменты, снижающие потребность в отладке","Контрактное программирование — чтобы программист подтверждал другим путём, что ему на выходе нужно именно такое поведение программы. 
Модульное тестирование — проверка поведения программы по частям.
Статический анализ кода — проверка кода на стандартные ошибки «по недосмотру».
Высокая культура программирования, в частности, паттерны проектирования, соглашения об именовании и прозрачное поведение отдельных блоков кода
Широкое использование проверенных внешних библиотек."
Основные команды CMD (Windows),Основные команды работы с каталогами,"MD - Создание каталога. (MD имя каталога, есть возможность указать путь расположения).
RD - Удаление каталога. (RD имя каталога, есть возможность указать путь расположения). Примечание, RD без ключей позволяет удалить только пустой каталог.
CD - Смена текущего каталога. (CD имя каталога, есть возможность указать путь расположения). CD\ - Переход в корневой каталог. CD.. - Переход в родительский 
DIR - Просмотр каталога ввиде списка.  (DIR имя каталога, есть возможность указать путь расположения).
TREE - Вывод каталогов в граффическом представлении. (TREE имя каталога, есть возможность указать путь расположения).
MOVE - Перемещение\Переименование каталога. (MOVE что_перемещаем куда_перемещаем, есть возможность указать путь расположения).
XCOPY - Копирование структур каталогов. (XCOPY что_копируем куда_копируем, есть возможность указать путь расположения)."
Основные команды CMD (Windows),Команды работы с файлами,"COPY CON - Создание файла. (COPY CON имя_файла_с_расширением, есть возможность указать путь расположения).
TYPE - Вывод содержимого файла на экран. (TYPE имя_файла_с_расширением, есть возможность указать путь расположения).
DEL - Удаление файла. (DEL имя_файла_с_расширением, есть возможность указать путь расположения).
COPY - Копирование файла\Обьединения файлов. (COPY что_копируем куда_копируем, есть возможность указать путь расположения). (COPY имя_файла + имя_файла + имя_файла... имя_файла_обьединения, есть возможность указать путь расположения).
EDIT - Создание\Редактирование файла. (EDIT имя файла, есть возможность указать путь расположения).
MOVE - Перемещение\Переименование файла. (MOVE что_перемещаем куда_перемещаем, есть возможность указать путь расположения).
REN - Переименование файлов. (REN что_переименовываем вочто_переименовываем, есть возможность указать путь расположения).
FC - Сравнение файлов. (FC имя_файла имя_файла имя_файла..., есть возможность указать путь расположения)."
Основные команды CMD (Windows),Команды системного назначения,"CLS - Отчистка экрана.
DATE - Просмотр и вывод на изменения текущей даты.
VER - Вывод информации о текущей версии Операционной системы.
VOL - Вывод информации о томе-логическом разделе диска.
SYSTEMINFO - Вывод инофрмации о конфигурациях системы.
EXIT - Выход из командной строки."
Умение написать CMD-файл,Командные файлы,"Текстовый файл, в котором набраны команды для cmd. Командным файлам принято давать расширение bat."
Умение написать CMD-файл,Передача командному файлу параметров,"Если при запуске командного файла пользователь указал несколько параметров, то в тексте командного файла первый из них мы обозначаем записью %1, второй записью %2, третий записью %3 и т.д. Этими обозначениями мы пользуемся в тексте командного файла."
Умение написать CMD-файл,Пример,"Следующий командный файл создает каталог с именем, указанным в первом параметре, и записывает в него файл с текстом описания команды, указанной во втором параметре.
rem Пример командного файла с двумя параметрами
rem Создаем каталог с именем, заданным первым параметром
md %1
rem Создаем в нем файл с описанием команды,
rem заданной вторым параметром
help %2 > %1\%2.help"
Умение написать CMD-файл,Некоторый синтаксис,"SET - переменная                             set help_compiler=c:\HTML Help Workshop\hcc.exe                           % help_compiler%
IF ELSE GOTO                                     if not ""%1""=="""" goto compile                           :compile
EXIST                                                   IF NOT EXIST %1.AAA
FOR                                                     for /r website %%i in (*.htm) do ren %%i %%~ni.html
CALL                                                    вызвать из одного командного файла другой командный файл"
"Навык использования IDE для разработки приложений (IDEA, Eclipse, VisualStudio, WebStorm, PhpStorm и т. д.)",IDE,"Интегрированная среда разработки. Комплекс программных средств, используемый программистами для разработки программного обеспечения (ПО).
Среда разработки включает в себя:
текстовый редактор,
компилятор и/или интерпретатор,
средства автоматизации сборки,
отладчик."
"Начальные навыки пользования сборщиком проектов (MsBuild, Maven, Ant и т. д.)",Сборщик проектов,"Сборщики проетов помогает оптимизировать процесс работы. Они могут преобразовывать одни файлы в другие, запушить изменения в GIT, автоматизировать тесты, минифицировать файлы, склеивать файлы.
Например если в проекте используется большое количество CSS или JS, чтобы клиенту не загружать большое количество файлов сборщик может объединить их в main.css или main.js"
Системы управления версиями (VCS). Умение пользоваться. (SVN/GIT/TFS/Subversion и т.д.),Система управления версиями,"Программное обеспечение для облегчения работы с изменяющейся информацией. Система управления версиями позволяет хранить несколько версий одного и того же документа, при необходимости возвращаться к более ранним версиям, определять, кто и когда сделал то или иное изменение, и многое другое."
Системы управления версиями (VCS). Умение пользоваться. (SVN/GIT/TFS/Subversion и т.д.),"Ветвление, branch","Отсутствие фиксации промежуточных изменений на сервере не позволяет работать над чем-либо в групповом режиме, кроме того, повышается риск потери изменений при локальных авариях и теряется возможность анализа и возврата к предыдущим вариантам кода в пределах данной работы. Поэтому для таких изменений обычной практикой является создание ветвей (branch), то есть «отпочковывание» от ствола в какой-то версии нового варианта проекта или его части, разработка в котором ведётся параллельно с изменениями в основной версии."
Системы управления версиями (VCS). Умение пользоваться. (SVN/GIT/TFS/Subversion и т.д.),Слияние версий,"Найденные наборы изменённых строк, которые не пересекаются между собой, считаются совместимыми и их слияние делается автоматически. Если в сливаемых файлах находятся изменения, затрагивающие одну и ту же строку файла, это приводит к конфликту. Такие файлы могут быть объединены только вручную."
Системы управления версиями (VCS). Умение пользоваться. (SVN/GIT/TFS/Subversion и т.д.),Конфликты и их разрешение,"Для разрешения конфликта система, в общем случае, предлагает разработчику три варианта конфликтующих файлов: базовый, локальный и серверный. Конфликтующие изменения либо показываются разработчику в специальном программном модуле объединения изменений"
Системы управления версиями (VCS). Умение пользоваться. (SVN/GIT/TFS/Subversion и т.д.),Блокировки,"Механизм блокировки позволяет одному из разработчиков захватить в монопольное использование файл или группу файлов для внесения в них изменений. На то время, пока файл заблокирован, он остаётся доступным всем остальным разработчикам только на чтение, и любая попытка внести в него изменения отвергается сервером. "
Системы управления версиями (VCS). Умение пользоваться. (SVN/GIT/TFS/Subversion и т.д.),Распределённые системы управления версиями,"Такие системы используют распределённую модель вместо традиционной клиент-серверной. Они, в общем случае, не нуждаются в централизованном хранилище: вся история изменения документов хранится на каждом компьютере, в локальном хранилище, и при необходимости отдельные фрагменты истории локального хранилища синхронизируются с аналогичным хранилищем на другом компьютере. В некоторых таких системах локальное хранилище располагается непосредственно в каталогах рабочей копии."
Навык использования системы ведения проектов (Jira),Jira,"Коммерческая система отслеживания ошибок, предназначена для организации взаимодействия с пользователями, хотя в некоторых случаях используется и для управления проектами."
Навык использования системы ведения проектов (Jira),Управление проектами," Область деятельности, в ходе которой определяются и достигаются четкие цели проекта при балансировании между объёмом работ, ресурсами (такими как деньги, труд, материалы, энергия, пространство и др.), временем, качеством и рисками."
Стили программирования,Процедурное программирование,"Выполнение программы сводится к последовательному выполнению операторов с целью преобразования исходного состояния памяти, то есть значений исходных данных, в заключительное, то есть в результаты. Таким образом, с точки зрения программиста имеются программа и память, причем первая последовательно обновляет содержимое последней."
Стили программирования,Функциональное программирование,"Функциональное программирование предполагает обходиться вычислением результатов функций от исходных данных и результатов других функций, и не предполагает явного хранения состояния программы. Соответственно, не предполагает оно и изменяемость этого состояния (в отличие от императивного, где одной из базовых концепций является переменная, хранящая своё значение и позволяющая менять его по мере выполнения алгоритма)."
Стили программирования,Логическое программирование,"Парадигма программирования, основанная на автоматическом доказательстве теорем, а также раздел дискретной математики, изучающий принципы логического вывода информации на основе заданных фактов и правил вывода. Логическое программирование основано на теории и аппарате математической логики с использованием математических принципов резолюций.
Центральным понятием в логическом программировании является отношение. Программа представляет собой совокупность определений отношений между объектами (в терминах условий или ограничений) и цели (запроса). Процесс выполнения программы трактуется как процесс общезначимости логической формулы, построенной из программы по правилам, установленным семантикой используемого языка. Результат вычисления является побочным продуктом этого процесса. "